:xrefstyle: short
:listing-caption: Listing
:table-caption: Tabelle
:source-language: c++
:icons: font
:source-highlighter: highlightjs

:cpp: C++
:cpp11: C++&ndash;11

= Potenzmenge

== Lernziele

* Einheitliche Initialisierung
* Initialisierungsliste (`std::initializer_list<T>`)
* STL-Klasse `std::set<T>`
* Container-Methoden `cbegin()` und `cend()`
* C++ Iteratorkonzept

== Einführung

Als Potenzmenge bezeichnet man in der Mengenlehre die Menge aller Teilmengen zu einer
gegebenen Grundmenge. Besitzt die Grundmenge den Namen _S_, notiert man die Potenzmenge meist
als _P_(_S_) von _S_. Für die 3-elementige Menge _S_ = { 1, 2, 3 } ergibt sich die Potenzmenge _P_({ 1, 2, 3 }) zu

....
P({1,2,3}) =
{
  {},
  {1},   {2},   {3},
  {1,2}, {1,3}, {2,3},
  {1,2,3}
}
....

Die Größe einer Potenzmenge (also die Anzahl aller Teilmengen) ist immer 2^n^,
wenn _n_ die Anzahl der Elemente der Grundmenge ist.
Erstellen Sie eine Implementierung für zwei Klassen `PowerSet` (Potenzmenge) und `PartialSet`
(Teilmenge, also ein Element einer Potenzmenge). Integrieren Sie dabei, soweit sinnvoll machbar, möglichst
viele programmiersprachliche Konstrukte bzw. Sprachmittel von _Modern_ {cpp}!

== Die Klasse `PartialSet`

Bevor wir uns dem Algorithmus zur Konstruktion einer Potenzmenge (und damit der Klasse `PowerSet`) zuwenden,
benötigen Sie als Fundament die Klasse `PartialSet`. Implementieren Sie ein Grundgerüst dieser Klasse
an Hand der Vorgaben in <<id_table_partialset>>.
Eine Instanz der Klasse `PartialSet` sollte ihre Elemente immer in aufsteigend sortierter Form ablegen.
Auf diese Weise lassen sich Operationen wie zum Beispiel das Vergleichen von `PartialSet`-Objekten leichter implementieren.

.Wesentliche Elemente der Klasse `PartialSet`.
[[id_table_partialset]]
[%autowidth]
|===
|Element |Beschreibung

| Konstruktor
a| Der Standardkonstruktor dient zum Erzeugen einer leeren Teilmenge.

[source,c++]
----
PartialSet() = default;
----

| Benutzerdefinierter Konstruktor
a| Der Konstruktor erzeugt eine Teilmenge. Mit `list` wird eine variabel lange Liste von Elementen übergeben,
die in der Teilmenge enthalten sind.

[source,c++]
----
PartialSet(const std::initializer_list<size_t>& list);
----

| _getter_ `size()`
a| Liefert die Anzahl der Elemente der Teilmenge zurück.

[source,c++]
----
size_t size() const;
----

| Methode `add()`
a| Fügt ein Element in die Teilmenge ein. Diese Methode wird zum algorithmischen Erzeugen einer Teilmenge benötigt.

[source,c++]
----
void add(size_t elem);
----

| Operator `==`
a| Vergleicht zwei `PartialSet`-Objekte auf Gleichheit. Zwei Teilmengen sind genau dann gleich, wenn sie die gleichen Elemente enthalten.

[source,c++]
----
friend bool operator==(const PartialSet&, const PartialSet&);
----

| Operator `<<`
a| Gibt ein `PartialSet`-Objekt auf der Konsole aus. Die Darstellung einer Teilmenge sollte folgendes Aussehen haben:

....
{ 1, 2, 3 }
....

[source,c++]
----
friend std::ostream& operator<< (std::ostream&, const Permutation&);
----
|===

Wir betrachten einige Testbeispiele:

[source,c++]
----
PartialSet set1{ };
std::cout << set1 << std::endl;

PartialSet set2{ 1, 2, 3 };
std::cout << set2 << std::endl;

PartialSet set3{ 3, 2, 1 };
std::cout << set3 << std::endl;
----

_Ausgabe_:

....
{ }
{ 1, 2, 3 }
{ 1, 2, 3 }
....

Man erkennt an der Ausgabe, dass die Mengen in aufsteigend sortierter Form vorliegen bzw. ausgegeben werden.

Test der `add`-Methode:

[source,c++]
----
PartialSet set{ };
set.add(3);
set.add(2);
set.add(1);
std::cout << set << std::endl;
----

_Ausgabe_:

....
{ 1, 2, 3 }
....


Test der Vergleichsoperatoren:

[source,c++]
----
PartialSet set1{ };
std::cout << set1 << std::endl;

PartialSet set2{ 1 };
std::cout << set2 << std::endl;

PartialSet set3{ 1, 2 };
std::cout << set3 << std::endl;

PartialSet set4{ 1, 2, 3 };
std::cout << set4 << std::endl;

std::cout << std::boolalpha << (set1 == set1) << std::endl;
std::cout << std::boolalpha << (set1 == set2) << std::endl;
std::cout << std::boolalpha << (set1 < set2) << std::endl;
std::cout << std::boolalpha << (set2 < set1) << std::endl;

std::cout << std::boolalpha << (set3 == set3) << std::endl;
std::cout << std::boolalpha << (set3 == set4) << std::endl;
std::cout << std::boolalpha << (set3 < set4) << std::endl;
std::cout << std::boolalpha << (set4 < set3) << std::endl;
----

_Ausgabe_:

....
{ }
{ 1 }
{ 1, 2 }
{ 1, 2, 3 }
true
false
true
false
true
false
true
false
....

== Eine intuitive Konstruktionsvorschrift für Potenzmengen

Für die algorithmische Berechnung einer Potenzmenge gibt es eine vergleichsweise einfache intuitive
Konstruktionsvorschrift. Um beim Beispiel einer Grundmenge mit den drei Elementen 1, 2, und 3 zu
bleiben: Wenn Sie im binären Zahlensystem alle Zahlen betrachten, die aus drei binären Ziffern
bestehen, also die binären Zahlen 000, 001, 010, 011, 100, 101, 110 und 111, zu welcher Beobachtung
gelangen Sie? Der Zusammenhang zwischen dem binären Zahlensystem und einer
korrespondierenden Potenzmenge sollte mit diesem Vergleich deutlich geworden sein: Identifizieren
wir jede dieser Zahlen mit einer Teilmenge der gegebenen Grundmenge und legen wir ferner fest,
dass eine binäre Ziffer _b_ spezifiziert, ob ein korrespondierendes Element in der Teilmenge enthalten
ist (_b_ = 1) oder nicht (_b_ = 0), so erhalten wir eine direkte Konstruktionsvorschrift für die Potenzmenge.
Am Beispiel einer Grundmenge mit den Elementen 1, 2 und 3 stellen wir diese Zuordnung zur
jeweiligen Teilmenge noch einmal exemplarisch gegenüber:

....
000 <-> { }
001 <-> { 1 }
010 <-> { 2 }
011 <-> { 1, 2 }
100 <-> { 3 }
101 <-> { 1, 3 }
110 <-> { 2, 3 }
111 <-> { 1, 2, 3 }
....

Wir legen also die Menge aller Kombinationen der Ziffern 0 und 1 zu Grunde, deren Anzahl sich – in
diesem Beispiel – zu 2^3^ berechnet.

== Die Klasse `PowerSet`

Wir fahren mit einigen Hilfestellungen zur Implementierung der Klasse `PowerSet` in <<id_table_powerset>> fort:

.Wesentliche Elemente der Klasse `PowerSet`.
[[id_table_powerset]]
[%autowidth]
|===
|Element |Beschreibung

| Konstruktor
a| Es wird die ein-elementige Potenzmenge erzeugt (bestehend aus der leeren Menge `{ }`).

[source,c++]
----
PowerSet();
----

| Benutzerdefinierter Konstruktor
a| Es wird die Potenzmenge zur Grundmenge { 1, 2, ..., _n_ } erzeugt.

[source,c++]
----
PowerSet(size_t n);
----

| _getter_ `size()`
a| Liefert die Anzahl der Elemente aus der Basismenge zurück.

[source,c++]
----
size_t size() const;
----

| _getter_ `cardinality()`
a| Liefert die Anzahl der Elemente der Potenzmenge zurück. _Hinweis_:
Besteht die Basismenge aus _n_ Elementen, so besitzt die Potenzmenge 2^_n_^ Teilmengen.

[source,c++]
----
size_t cardinality() const;
----

| Operator `<<`
a| Gibt ein `PowerSet`-Objekt auf der Konsole aus.

[source,c++]
----
friend std::ostream& operator<< (std::ostream&, const PowerSet&);
----
|===

Es folgen einige Beispiele zur Klasse `PowerSet`.
Studieren Sie diese sorgfältig und stimmen Sie Ihre Realisierung darauf ab:

_Beispiel_ 1:

[source,c++]
----
PowerSet set{ };
std::cout << "Size: " << set.size() << ", Cardinality: " << set.cardinality() << std::endl;
std::cout << set << std::endl;
----

_Ausgabe_:

....
Size: 0, Cardinality: 1
{ }
....

_Beispiel_ 2:

[source,c++]
----
PowerSet set{ 1 };
std::cout << "Size: " << set.size() << ", Cardinality: " << set.cardinality() << std::endl;
std::cout << set << std::endl;
----

_Ausgabe_:

....

Size: 1, Cardinality: 2
{ }
{ 1 }
....

_Beispiel_ 3:

[source,c++]
----
PowerSet set{ 2 };
std::cout << "Size: " << set.size() << ", Cardinality: " << set.cardinality() << std::endl;
std::cout << set << std::endl;
----

_Ausgabe_:

....
Size: 2, Cardinality: 4
{ }
{ 1 }
{ 1, 2 }
{ 2 }
....

_Beispiel_ 4:

[source,c++]
----
PowerSet set{ 3 };
std::cout << "Size: " << set.size() << ", Cardinality: " << set.cardinality() << std::endl;
std::cout << set << std::endl;
----

_Ausgabe_:

....
Size: 3, Cardinality: 8
{ }
{ 1 }
{ 1, 2 }
{ 1, 2, 3 }
{ 1, 3 }
{ 2 }
{ 2, 3 }
{ 3 }
....

== Sortierung einer Potenzmenge

In dieser Teilaufgabe betrachten wir die sortierte Ausgabe aller Teilmengen einer Potenzmenge.
Im Prinzip geht es darum, ein Kriterium für den Vergleich zweier Teilmengen festzulegen.
Wenn Sie Ihre bisherige Implementierung betrachten, sollten Sie bei der Berechnung der Potenzmenge zur Basismenge { 1, 2, 3, 4 }
die folgende Ausgabe erhalten:

....
Size: 4, Cardinality: 16
{ }
{ 1 }
{ 1, 2 }
{ 1, 2, 3 }
{ 1, 2, 3, 4 }
{ 1, 2, 4 }
{ 1, 3 }
{ 1, 3, 4 }
{ 1, 4 }
{ 2 }
{ 2, 3 }
{ 2, 3, 4 }
{ 2, 4 }
{ 3 }
{ 3, 4 }
{ 4 }
....

Wie müssten Sie einen Operator `<` in der Klasse `PartialSet` definieren, um die folgende Ausgabe zu erhalten:

....
{ }
{ 1 }
{ 2 }
{ 3 }
{ 4 }
{ 1, 2 }
{ 1, 3 }
{ 1, 4 }
{ 2, 3 }
{ 2, 4 }
{ 3, 4 }
{ 1, 2, 3 }
{ 1, 2, 4 }
{ 1, 3, 4 }
{ 2, 3, 4 }
{ 1, 2, 3, 4 }
....


.Definition des Operators `operator<` in der Klasse `PartialSet`.
[[id_table_partialset]]
[%autowidth]
|===
|Operator |Beschreibung

| Operator `<`
a| Vergleicht zwei `PartialSet`-Objekte auf &ldquo;kleiner&rdquo;.
Wir bezeichnen eine Teilmenge __S__1 &ldquo;kleiner&rdquo; als eine Teilmenge __S__2,
wenn __S__1 entweder weniger Elemente als __S__2 enthält oder, falls __S__2 gleich viel Elemente enthält,
das erste Element von __S__1 kleiner ist als das erste Element von __S__2.
Stimmen beide Teilmengen im ersten Element überein, setzen wir den Vergleich mit dem zweiten, dritten, etc. Element solange fort,
bis ein Unterschied vorhanden ist. Dabei wird vorausgesetzt,
dass die Elemente beider Teilmengen in aufsteigender Reihenfolge vorliegen.

[source,c++]
----
friend bool operator<(const PartialSet&, const PartialSet&);
----
|===

== Aufzählung einer Potenzmenge

Bei Objekten, die den Charakter eines Containers besitzen (Menge aller Schriftarten auf einem Rechner, Menge aller laufenden Prozesse, etc.)
gibt es die Möglichkeit, die einzelnen Elemente eines solchen Objekts der Reihe nach aufzuzählen (so genannte &ldquo;Traversierung der Menge&rdquo;).
Auf das Beispiel der Potenzmenge angewendet ergänzen wir die Klasse `PowerSet` um die beiden Methoden `begin()` und `end()`, die die zum Iterieren
notwendigen Objekte für den Start und das Ende einer Aufzählung bereitstellen:

.Aufzählung einer Potenzmenge
[[id_table_powersetset_iterator]]
[%autowidth]
|===
|Methode |Beschreibung

| `begin()`
a| Liefert ein Iterator-Objekt zurück, das auf das erste `PartialSet`-Objekt verweist.

[source,c++]
----
std::set<PartialSet>::const_iterator begin();
----

| `end()`
a| Liefert ein Iterator-Objekt zurück, das hinter das letzte Element zeigt.

[source,c++]
----
std::set<PartialSet>::const_iterator end();
----
|===

Studieren und testen Sie Ihre Funktionsweise der Iterator-Realisierung an einer bereichs-basierten Wiederholungsschleife:

_Beispiel_ 4:

[source,c++]
----
PowerSet powerSet{ 3 };
for (const PartialSet& set : powerSet) {
    std::cout << "Next Set: " << set << std::endl;
}
----

_Ausgabe_:

....
Next Set: { }
Next Set: { 1 }
Next Set: { 2 }
Next Set: { 3 }
Next Set: { 1, 2 }
Next Set: { 1, 3 }
Next Set: { 2, 3 }
Next Set: { 1, 2, 3 }
....

== Teilmengen einer Potenzmenge

Von einer Potenzmenge lassen sich Teilmengen bilden. Zum Beispiel kann man alle Elemente einer
Potenzmenge betrachten, die dieselbe Anzahl _k_ von Elementen besitzen. Dazu betrachten wir am
besten ein Beispiel: Alle zwei-elementigen Teilmengen der Potenzmenge, deren Grundmenge aus
den Elementen 0, 1, und 2 besteht, lauten {0, 1}, {0, 2} und {1, 2}.
Ergänzen Sie Ihre Realisierung der Klasse `PowerSet` um eine Methode `partialSetsBySize`:

.Teilmengen einer Potenzmenge
[[id_table_powersetset_method_partialsetsbysize]]
[%autowidth]
|===
|Methode |Beschreibung

| `partialSetsBySize()`
a| Berechnet alle Teilmengen einer Potenzmenge mit der Größe `size`.

[source,c++]
----
PowerSet partialSetsBySize(size_t size);
----

|===

Ein Beispiel:

[source,c++]
----
PowerSet powerSet{ 5 };
size_t size = 3;
PowerSet someSets = powerSet.partialSetsBySize(size);
std::cout << "Partial set of size " << size << ':' << std::endl;
for (const PartialSet& set : someSets) {
    std::cout << set << std::endl;
}
----

_Ausgabe_:

....
Partial set of size 3:
{ 1, 2, 3 }
{ 1, 2, 4 }
{ 1, 2, 5 }
{ 1, 3, 4 }
{ 1, 3, 5 }
{ 1, 4, 5 }
{ 2, 3, 4 }
{ 2, 3, 5 }
{ 2, 4, 5 }
{ 3, 4, 5 }
....

== There is more

Unsere bisherigen Betrachtungen einer Potenzmenge haben sich ausschließlich auf Grundmengen mit ganzen Zahlen beschränkt.
Für die Grundmenge kann man aber auch die Annahme treffen, dass deren integraler Datentyp (`int`, `short`, `long`, `size_t`, etc.) variabel sein sollte.
Auch kann man sich eine Grundmenge aus Zeichen (`char`) vorstellen.
Welche Änderungen sind an den beiden Klassen `PartialSet` und `PowerSet` vorzunehmen,
um die Grundmenge mit unterschiedlichen integralen Datentypen definieren zu können?
