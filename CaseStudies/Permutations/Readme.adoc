:xrefstyle: short
:listing-caption: Listing
:table-caption: Tabelle

= Permutationen

== Beschreibung

Ist eine Menge von _n_ Elementen gegeben, so bezeichnet man die möglichen Anordnungen aller dieser _n_ Elemente als Permutationen (lat. permutare: vertauschen). Die Berechnung der Permutationen einer beliebigen Menge von Elementen steht im Mittelpunkt dieser Aufgabe. Als Elemente verwenden wir Zeichen, also `char`-Variablen.

Für zwei Zeichen `A` und `B` gibt es nur die zwei Permutationen `AB` und `BA`. Drei Zeichen, angenommen `A`, `B` und `C`, können hingegen in sechs verschiedenen Permutationen dargestellt werden: `ABC`, `ACB`, `BAC`, `BCA`, `CAB` und `CBA`. Sind alle _n_ Elemente voneinander verschieden, was wir in dieser Aufgabe zu Grunde legen, so gibt es dafür _n_! Anordnungen (_n_-Fakultät).

Bevor wir auf den Algorithmus zur Berechnung von Permutationen eingehen, entwickeln wir zwei Hilfsklassen `Permutation` und `PermutationArray`.

== Klasse `Permutation`

Die Klasse `Permutation` benötigen wir, um eine einzelne Permutation darzustellen.
Überlegen Sie, welcher Container der STL dafür geeignet sein könnte?
Die Details zur Schnittstelle der Klasse `Permutation` sind in Tabelle 1 zusammengestellt:

.Wesentliche Elemente der Klasse `Permutation`.
[[id_table_permutation]]
[%autowidth]
|===
|Element |Beschreibung

| Konstruktor
a| Der Standardkonstruktor initialisiert ein leeres `Permutation`-Objekt: Es enthält keine Zeichen und die Anzahl der Zeichen ist dementsprechend 0.

[source,c++]
----
Permutation() = default;
----
| Benutzerdefinierter Konstruktor
a| Der Konstruktor initialisiert ein `Permutation`-Objekt an Hand der Elemente eines `std::vector<char>`-Objekts.
Sinnvollerweise sollten die Zeichen in dem Vektor `vec` alle voneinander verschieden sein. Sie brauchen das in Ihrer Implementierung aber nicht zu überprüfen.

[source,c++]
----
Permutation(const std::vector<char> vec);
----
| Benutzerdefinierter Konstruktor
a| Der Konstruktor initialisiert ein `Permutation`-Objekt an Hand der Elemente eines `std::string_view`-Objekts.
Wiederum sollten die Zeichen des Parameters `sv` alle voneinander verschieden sein, Sie brauchen das in Ihrer Implementierung aber nicht zu überprüfen.

[source,c++]
----
Permutation(const std::string_view sv);
----
| _getter_
a| Liefert die Anzahl der `char`-Elemente zurück, die im Objekt abgelegt sind. Man spricht auch von der _Länge_ bzw. vom _Grad_ der Permutation.

[source,c++]
----
int grade() const;
----
| Methode `insertAtFront`
a| Die `insertAtFront`-Methode verändert die aktuelle Permutation wie folgt: Das übergebene Zeichen `ch` wird in der vorliegenden Permutation am Anfang eingefügt.
Inbesondere wird der Grad der Permutation damit um Eins größer.

_Hinweis_: Die `insertAtFront`-Methode benötigen wir für den Algorithmus zur Berechnung von Permutationen!

[source,c++]
----
void insertAtFront(char ch);
----
| Methode `removeAt`
a| Die `removeAt`-Methode erzeugt eine neue Permutation, die aus der aktuellen Permutation durch Entfernen des _i_.-ten Zeichens entsteht.
Die vorliegende Permutation bleibt unverändert. Der Grad der neuen Permutation ist folglich um Eins kleiner als der Grad der aktuellen Permutation.

_Hinweis_: Die `insertAtFront`-Methode benötigen wir für den Algorithmus zur Berechnung von Permutationen!

[source,c++]
----
Permutation removeAt(int i) const;
----
| Operator `[]`
a| Liefert das _i_.-te Zeichen der Permutation zurück.

[source,c++]
----
char operator[] (int i) const;
----
| Operator `<<`
a| Gibt ein `Permutation`-Objekt auf der Konsole aus. Die einzelnen Zeichen der Permutation sind durch Komma voneinander zu trennen,
die Permutation selbst ist in eckige Klammern `[` und `]` zu setzen.

[source,c++]
----
friend std::ostream& operator<< (std::ostream& os, const Permutation& p);
----
|===

Es folgen einige Beispiele, um die Arbeitsweise der Klasse `Permutation` zu verdeutlichen.
Eine Permutation mit den drei Zeichen `'A'`, `'B'` und `'C'` wird so angelegt:

[source,c++]
----
Permutation p("ABC");
std::cout << p << std::endl;
----

_Ausgabe_:

....
[A,B,C]
....

Noch ein ähnliches Beispiel mit einer Permutation der fünf Zeichen bzw. Ziffern `'1'`, `'2'`, `'3'`, `'4'` und `'5'`:

[source,c++]
----
Permutation p({ '1', '2', '3', '4', '5' });
std::cout << p << " (Anzahl der Elemente: " << p.grade() << ')' << std::endl;
----

_Ausgabe_:

....
[1,2,3,4,5] (Anzahl der Elemente: 5)
....

Ein Beispiel zur `grade`-Methode und dem `[]`-Operator könnte so aussehen:

[source,c++]
----
Permutation p("ABC");
for (int i = 0; i < p.grade(); i++)
{
    char ch = p[i];
    std::cout << i << ": " << ch << std::endl;
}
----

_Ausgabe_:

....
0: A
1: B
2: C
....

Wir schließen mit einem Beispiel zur `insertAtFront`-Methode ab:

[source,c++]
----
Permutation p("ABC");
std::cout << p << " (Grad: " << p.grade() << ')' << std::endl;
p.insertAtFront('D');
std::cout << p << " (Grad: " << p.grade() << ')' << std::endl;
----

_Ausgabe_:

....
[A,B,C] (Grad: 3)
[D,A,B,C] (Grad: 4)
....

== Klasse `PermutationArray`

Zum Abspeichern mehrerer Permutation-Objekte konzipieren wir eine Klasse `PermutationArray`.
`PermutationArray`-Objekte sind vor allem dann hilfreich, wenn während der Berechnung der Permutationen bereits eine (unvollständige) Menge an Permutation-Objekten vorliegt.
Die Anzahl der Permutationen, die in einem `PermutationArray`-Objekt abzulegen sind, steht immer im vornehinein fest.
Diese Eigenschaft können wir dazu verwenden, dass zu Grunde liegende STL-Container-Objekt geeignet vorzubelegen.

Die Klasse `PermutationArray` besitzt eine Reihe von Methoden, die speziell für den Algorithmus zur Berechnung von Permutationen ausgelegt sind:


.Wesentliche Elemente der Klasse `PermutationArray`.
[[id_table_permutationarray]]
[%autowidth]
|===
|Element |Beschreibung

| Konstruktor
a| Der Standardkonstruktor initialisiert ein leeres `PermutationArray`-Objekt.

[source,c++]
----
PermutationArray() = default;
----
| Benutzerdefinierter Konstruktor
a| Initialisiert ein `PermutationArray`-Objekt so, dass das zu Grunde liegende STL-Container-Objekt
für die Aufnahme von `capacity` Permutationen-Objekten vorbereitet ist.

[source,c++]
----
PermutationArray(int capacity);
----
| _getter_
a| Liefert die Anzahl der `Permutation`-Elemente zurück, die im Objekt abgelegt sind.

[source,c++]
----
int count() const;
----
| Methode `insert`
a| Fügt ein `Permutation`-Objekt in das `PermutationArray`-Objekt ein.

[source,c++]
----
void insert(const Permutation&);
----
| Methode `emplace`
a| Fügt ein `Permutation`-Objekt in das `PermutationArray`-Objekt ein. Die Vorgehensweise soll in diesem Fall _in-place_ erfolgen.

[source,c++]
----
void emplace(std::string_view&&) noexcept;
----
| Methode `emplace`
a| Fügt ein `Permutation`-Objekt in das `PermutationArray`-Objekt ein. Die Vorgehensweise soll in diesem Fall _in-place_ erfolgen.

[source,c++]
----
void emplace(std::vector<char>&&) noexcept;
----
| Methode `insertAll`
a| Ruft die Methode `insert` an allen `Permutation`-Objekten im vorliegenden `PermutationArray`-Objekt mit dem Parameter `ch` auf.

[source,c++]
----
void insertAll(char ch);
----
| Operator `[]`
a| Liefert das _i_.-te `Permutation`-Objekt aus dem zu Grunde liegenden `PermutationArray`-Objekt zurück.

[source,c++]
----
Permutation operator[] (int) const;
----
| Operator `<<`
a| Gibt ein `PermutationArray`-Objekt auf der Konsole aus: Es sind alle im Array ablegten Permutationen auf der Konsole untereinander auszugeben.

[source,c++]
----
friend std::ostream& operator<< (std::ostream& os, const PermutationArray& p);
----
|===

Ein Beispiel zur `PermutationArray`-Klasse könnte so aussehen:

[source,c++]
----
Permutation p("ABC");
Permutation q("CBA");
PermutationArray array(2);
array.insert(p);
array.insert(q);
std::cout << array << std::endl;
----

_Ausgabe_:

....
[A,B,C]
[C,B,A]
[2 permutations]
....

== Algorithmus zur Berechnung von Permutationen

Nun fehlt nur noch ein Algorithmus, um zu einer gegebenen Menge von Elementen alle Permutationen zu berechnen. Ein sehr einfacher – rekursiver – Algorithmus lässt sich in Worten so beschreiben, wenn _n_ die Anzahl der Elemente ist:

Erster Fall: _n_ = 1

Die Menge hat nur ein Element, nennen wir es a~1~. Es existiert in diesem Fall nur eine einzige Permutation, bestehend aus dem Element a~1~ selbst.

Zweiter Fall: _n_ > 1

Wir bezeichnen die Elemente mit a~1~, a~2~, a~3~, ... , a~_n_-1~, a~_n_~: Nun ist der Reihe nach jedes einzelne Element a~_i_~ (i = 1,2, ..., n)
vorrübergehend aus der vorliegenden Menge von _n_ Zeichen zu entfernen. Die zurückbleibenden _n_-1 Elemente werden nun mit diesem Algorithmus (rekursiv) permutiert.
Der rekursive Methodenaufruf liefert als Ergebnis eine Menge von Permutationen zurück, die alle den Grad _n_-1 besitzen.
Das entfernte Zeichen ist nun in diese Permutationen wieder einzufügen. Die Einfügeposition spielt dabei keine Rolle, wir entscheiden uns für den Anfang, siehe dazu auch die `insert`-Methode aus Tabelle 1.

Mit Hilfe der Vorarbeiten der zwei Klassen `Permutation` und `PermutationArray` (<<id_table_permutation>> und <<id_table_permutationarray>>) 
können wir den vorgestellten Algorithmus etwas präziser formulieren: In Abbildung 3 finden Sie Pseudo-Code für eine Methode `calculate` vor:

[caption="Abbildung {counter:figure}: ", title="Pseudo-Code der Methode `calculate`."]
image::PermutationPseudeCode.png[width=450]

== Klasse `PermutationCalculator`

Wir sind fast am Ziel angekommen: Die im letzen Abschnitt beschriebe Methode `calculate` ordnen wir der Klasse `PermutationCalculator` zu.
Die Definition in Tabelle 3 stellt im Prinzip nur eine Wiederholung dar:

.Methode `calculate` der Klasse `PermutationCalculator`.
[[id_table_permutationcalculator]]
[%autowidth]
|===
|Methode |Beschreibung

| `calculate`
a| Berechnet alle Permutationen zu einer vorgegebenen Menge von Zeichen, die durch die Permutation `p` beschrieben werden.
Das Ergebnis ist in einem Objekt des Typs `PermutationArray` abzulegen.

[source,c++]
----
PermutationArray calculate(const Permutation& p);
----
|===

Nachfolgend ein Beispiel, wie Sie die Klasse `PermutationCalculator` zur Berechnung von Permutationen einsetzen:

[source,c++]
----
Permutation p("ABC");
PermutationCalculator calc;
PermutationArray result = calc.calculate(p);
std::cout << result << std::endl;
----

_Ausgabe_:

....
[A,B,C]
[A,C,B]
[B,A,C]
[B,C,A]
[C,A,B]
[C,B,A]
[6 permutations]
....


## Aufzählung von Permutationen

In Work

## Lösung

### Klasse `Permutation`

Zur Realisierung der Klasse `Permutation` bietet sich für die Ablage der Zeichen der Permutation ein STL-Containerobjekt des Typs `std::vector<char>` an:

[source,c++]
----
class Permutation
{
private:
    std::vector<char> m_values;
    ...
----

Dieser Vektor kann mit einem geeigneten Konstruktor und der so genannten &ldquo;Initialisierungsliste&rdquo; (engl. &ldquo;List Initialization&rdquo;, seit C++ 11)
elegant vorbelegt werden. Eigentlich hat der in Frage kommende Konstruktor einen Parameter des Typs `std::vector<char>`.
Wir müssen beim Anlegen eines `Permutation`-Objekts aber nicht zwingend vor dem Aufruf ein  `std::vector<char>`-Objekt explizit anlegen.
Wir können stattdessen eine Menge von Zeichen in geschweifte Klammern setzen und an den Konstruktor übergeben:

[source,c++]
----
Permutation::Permutation(const std::vector<char>& values) : m_values{ values }{}
...
Permutation p({ '1', '2', '3' , '4' , '5' });
----

Dieser Quellcode basiert auf der Tatsache, dass der Konstruktor der Klasse `std::vector<T>`, der ein `std::initializer_list<T>`-Objekt erwartet,
nicht als `explicit` definiert ist. Damit kann der Übersetzter implizit eine Wandlung von einer Initialisierungsliste in ein `std::vector<T>`-Objekt durchführen.
Im Rumpf des Konstruktors erhalten wir folglich - dank des Übersetzers - ein `std::vector<T>`-Objekt, das wir der `m_values`-Variablen zuweisen können.
Diese Wertzuweisung habe ich syntaktisch im der Initialisierungsliste des Konstruktors vorgenommen,
und dabei ist zu beachten, dass die geschweiften Klammern dieses Mal für das so genannten Feature der &ldquo;einheitlichen Initialisierung&rldquo;
(engl. &ldquo;Uniform Initialization&rdquo;, seit C++ 11) stehen. Dieses Schreibweise bildet zusammen mit der Initialisierungsliste 
den Ansatz von Modern C++, den Themenbereich der Initialisierung von Variablen und Objekten zu vereinheitlichen.


Da wir aktuell Permutationen von Zeichen (`char`) betrachten, macht es Sinn, auch Zeichenketten zur Initialisierung zu verwenden.
Die `std::string`-Klasse wäre ein erster Ansatz, ab C++ 17 besitzt diese Klasse einen _leichtgewichtigen_ Partner in Gestalt der Klasse `std::string_view`.
Vereinfacht formuliert kann man sagen, dass `std::string_view`-Objekte eine unveränderbare Darstellung einer Zeichenkette sind.
Zum Zwecke der Initialisierung kann man diese Klasse so einsetzen:

[source,c++]
----
Permutation::Permutation(const std::string_view s) {
    m_values = std::vector<char> (s.begin(), s.end());
}
...
Permutation p1("12345");
----

Um die Instanzvariable `m_values` der Klasse `Permutation` mit einem `std::string_view`-Objekt vorzubelegen, gibt es 
in der Klasse `std::vector` einen geeigneten Konstruktor, der zwei Iteratoren erwartet. Damit kann der (unveränderbare) Inhalt des Parameters `s`
im Vektor abgelegt werden.

Die beiden Methoden  `insertAtFront` und  `removeAt` und der `[]`-Operator lassen sich ohne nennenswerten Aufwand realisieren:

[source,c++]
----
void Permutation::insertAtFront(char ch)
{
    m_values.insert(m_values.begin(), ch);
}

Permutation Permutation::removeAt(int i) const
{
    std::vector<char> tmp = m_values;
    tmp.erase(tmp.begin() + i);
    return Permutation(tmp);
}

char Permutation::operator[] (int i) const
{
    return m_values[i];
}
----

### Klasse `PermutationArray`

Kurz und bündig formuliert sind `PermutationArray`-Objekte Container für Permutationen. 
Dies ließe sich einfach und unmittelbar mit einer STL-Containerklasse wie zum Beispiel `std::vector<T>` erzielen.
Da der gleich folgendende Algorithmus zur Berechnung aller Permutationen diese sukzessive berechnet und dabei auch noch einige Hilfsmethoden
erfordert, sind wir gut beraten, wenn wir um eine `std::vector<T>`-Objekt eine Hüllenklasse schreiben, die für die Belange des Algorithmus
ausgelegt ist.

Auf die Schnelle lassen sich `Permutation`-Objekte einfach in einem `PermutationArray`-Objekt ablegen.
Wir implementieren eine insert-Methode, die wir auf eine push_back Methode umsetzen.

Die einzige Stoperfalle, die es zu beachten gilt, ist, dass wir XX Objekte nicht call-by-valie, sondern by_ref durchreichen,
um unnötihe Kopiene zhu vermeiden

#### _We can do better_: _In-Place_ Konstruktion mit `emplace`

